# 什么是编译？

答：**编译就是从一种程序形式到另一种程序形式的转换算法，其转换保持语义等价**。

你理解“算法”是什么吗？那么请回答以下问题：算法和程序的区别是什么？

## 算法与程序

算法可能有很多定义和其它宽泛的解释，但这里我们采用这种狭隘的定义：算法是一个从输入域到输出域的可计算映射。在数学中，映射也被称为函数，所以，“算法就是可计算的函数”。

> 我不会在这里进一步阐述“可计算”这个概念，如果你想了解更多，请参考[《Computability theory - Wikipedia》](https://en.wikipedia.org/wiki/Computability_theory)。

程序，相比而言，则没有那么严格的定义。按通常的理解，程序就是“确定性的动作序列”（虽然这个定义有点命令式编程或过程式编程的刻板印象）。

它们的关系就是：所有算法都是程序，但并不是所有程序都是算法。而个中区别就在于：程序有输出输出（IO），而算法就是单纯的从输入到输出的变换。

> 该区别通常也被称为[“副作用”（side effect）](<https://en.wikipedia.org/wiki/Side_effect_(computer_science)>)。

例如：

```c
// 求和数组 [a, a+n) 的整数
int sum(const int* a, int n);
// 将数组 [a, a+n) 的整数发送到某个地方，返回发送长度
int send(const int* a, int n);
```

`sum` 是一个算法，而 `send` 则不是算法。

对于前者而言，如果有什么神奇的方法，使得我们不用计算就能知道 `[a, a+n)` 的和，那么就完全没有必要调用 `sum` 函数。也就是说，对于下面的代码，完全可以把 `sum` 函数删掉，直接替换为结果，那么程序的行为不会有任何变化：

```c
int a[] = {1, 2, 3, 4, 5}, b;
// b = sum(a, 5);
b = 15;
```

在另一方面，你永远也不知道 `send` 函数做了什么事情，会产生什么影响，因此你别无选择，必须忠实地调用它，执行它的语义，以确保程序的正确性。对于下面的代码，如果你将 `send` 的调用直接替换为了结果，那么程序就可能是错的，系统可能就无法正常工作：

```c
int a[] = {1, 2, 3, 4, 5}, b;
b = send(a, 5);
// b = 5;
```

显然，一般而言，“程序”要比“算法”要难理解，对于“算法”而言，你只需要知道它输入和输出之间是怎么映射的就行了，而对于“程序”而言，你还需要知道它的具体执行过程，评估它的影响等等。

## 编译是算法

幸运的是，“编译”本质上是一个“算法”，“编译器”本质上就是一个“算法程序”，就像下面这个函数，它把 C 语言编译到 D 语言：

```c
D_code compile(C_code src);
```

> 对于 JIT 编译而言，这个函数可能长成这样：
>
> ```c
> void* compile(C_code src);
> ```
>
> 它返回一个函数指针，然后这样使用：
>
> ```c
> void* f = compile(src);
> int result = ((int (*)(int))f)(42); // 转成所需的函数指针类型
> ```

然而，编译算法与你之前遇到的算法（比如排序、查找、或是 LeetCode 上的作业题）有很大的不同，这个不同在于：它特别复杂，你不可能一节课就能学会，也不可能花几个小时就能写出来。

这种复杂性从何而来呢？并不是人们故意使它复杂，而是它的输入和输出域决定的。和一般算法不同，编译算法的输入和输出域就是“程序”本身。对于一般算法，我们可以自由设计它输入和输出数据的格式以便处理；而对于编译，“程序”的格式往往是“天然的”，就好比人类的语言一样，不是某个人设计出来的，而是自然演化出来的。

事实上，“程序”这一事物本身是如此复杂，以至于很多时候编译器的实现本身就直接充当算法输入域的定义（类似数学函数的自然定义域）。例如，所有编程语言在发布时都会提供一个“基准实现”或“参考实现”，而有些时候，这个基准实现中的设计缺陷也不得不被后来的实现所继承，哪怕是无心为之。

> **编译器的复杂性来自于“程序”这一事物固有的复杂性**，良好的设计只是将此之外的复杂性降到最低而已。

编译是算法，而算法是函数，如同在数学中一样，我们应当指出它的三要素：

- 输入：源语言所能表达程序的集合，称为“源程序”；
- 输出：目标语言所能表达程序的集合，称为“目标程序”；
- 映射：源程序和目标程序有相同的语义。

理解算法的第一步就是理解算法的输入输出域。所以，理解编译的输入输出域，即理解“程序的形式”就是打开编译器设计大门的钥匙。

---

# 接下来：[《程序的形式》](./程序的形式.md)
